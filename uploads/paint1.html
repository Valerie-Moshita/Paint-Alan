<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Paint por N√∫meros</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #f4f6f8; margin: 0; padding: 20px; }
    h1 { margin-bottom: 10px; }
    #controls { margin: 10px 0; }
    #palette { margin: 15px 0; }
    #palette button { width: 30px; height: 30px; border: 2px solid #222; margin: 2px; cursor: pointer; }
    #canvas { border: 1px solid #333; background: #fff; cursor: crosshair; }
  </style>
</head>
<body>
  <h1>Paint por N√∫meros</h1>

  <div id="controls">
    <input type="file" id="fileInput" accept=".png,.jpg,.jpeg,.svg" />
    <button onclick="resetCanvas()">üîÑ Limpiar colores</button>
    <button onclick="downloadImage()">‚¨áÔ∏è Descargar</button>
  </div>

  <div id="palette"></div>
  <canvas id="canvas" width="800" height="600"></canvas>

<script>
/* ---------- Config ---------- */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let currentColor = 'red';
let currentImage = null; // para saber si es raster (png/jpg) o svg
const colors = ['red','blue','green','yellow','orange','purple','pink','brown','black','white'];

/* ---------- Crear paleta ---------- */
const palette = document.getElementById('palette');
colors.forEach(c => {
  const btn = document.createElement('button');
  btn.style.background = c;
  btn.onclick = () => currentColor = c;
  palette.appendChild(btn);
});

/* ---------- Carga de im√°genes ---------- */
document.getElementById('fileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;

  const ext = file.name.split('.').pop().toLowerCase();
  if (ext === 'svg') {
    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      const svg = new Blob([ev.target.result], {type: 'image/svg+xml'});
      const url = URL.createObjectURL(svg);
      img.onload = () => {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        currentImage = 'svg';
        URL.revokeObjectURL(url);
      };
      img.src = url;
    };
    reader.readAsText(file);
  } else { // PNG/JPG
    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        currentImage = 'raster';
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  }
});

/* ---------- Pintar en raster con floodFill ---------- */
canvas.addEventListener('click', e => {
  if (currentImage !== 'raster') return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(e.clientX - rect.left);
  const y = Math.floor(e.clientY - rect.top);
  floodFill(x, y, currentColor, 40); // tolerancia
});

function floodFill(startX, startY, fillColor, tolerance = 40) {
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  const i = (startY * canvas.width + startX) * 4;
  const targetColor = [data[i], data[i+1], data[i+2], data[i+3]];
  const [fr, fg, fb, fa] = colorToRGBA(fillColor);

  if (colorsClose(...targetColor, fr, fg, fb, fa, tolerance)) return;

  const stack = [[startX, startY]];

  while (stack.length) {
    const [x, y] = stack.pop();
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;

    const idx = (y * canvas.width + x) * 4;
    const r = data[idx], g = data[idx+1], b = data[idx+2], a = data[idx+3];

    if (colorsClose(r, g, b, a, ...targetColor, tolerance)) {
      data[idx] = fr;
      data[idx+1] = fg;
      data[idx+2] = fb;
      data[idx+3] = fa;

      stack.push([x+1,y]);
      stack.push([x-1,y]);
      stack.push([x,y+1]);
      stack.push([x,y-1]);
    }
  }

  ctx.putImageData(imageData, 0, 0);
}

function colorsClose(r1,g1,b1,a1, r2,g2,b2,a2, tolerance) {
  return (
    Math.abs(r1-r2)<=tolerance &&
    Math.abs(g1-g2)<=tolerance &&
    Math.abs(b1-b2)<=tolerance
  );
}

function colorToRGBA(color) {
  const tempCtx = document.createElement('canvas').getContext('2d');
  tempCtx.fillStyle = color;
  tempCtx.fillRect(0, 0, 1, 1);
  return [...tempCtx.getImageData(0,0,1,1).data];
}

/* ---------- Limpiar y descargar ---------- */
function resetCanvas(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  currentImage = null;
}

function downloadImage(){
  const link = document.createElement('a');
  link.download = 'pintado.png';
  link.href = canvas.toDataURL();
  link.click();
}
</script>
</body>
</html>
